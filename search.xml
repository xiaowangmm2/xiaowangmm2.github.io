<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[visual快捷键]]></title>
    <url>%2Fposts%2F81cd6102%2F</url>
    <content type="text"><![CDATA[一、快捷键查找 Ctrl+F查找下一个 F3 或者 Ctrl+F3查找上一个 Shift+F3跳到第几行 Ctrl+G向下向上复制本行 Alt + Shift +箭头键(←,↑,↓,→)向下向上移动本行 Alt +箭头键(←,↑,↓,→)从头到尾选择整行 Shift + End从尾到头选择整行 Shift + Home打开命令版 F1 或 Ctrl+Shift+P搜索某个文件 Ctrl+P选择左右匹配项 Ctrl+Shift+L终端弹出 Ctrl+`多光标 ALt]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>visual</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm命令]]></title>
    <url>%2Fposts%2F90f8805%2F</url>
    <content type="text"><![CDATA[一、命令大全命令行api，快戳我 npm list [-g] 查看所有[全局安装]的模块 (ls、la &amp; ll 可以用作 list 的别名) npm list –depth=0 [-g] 查看[全局]安装的包 npm list grunt 查看某个模块的版本号 npm uninstall express 卸载express模块。 npm update express 更新某个模块 npm info express 可以查看到express在npm上发布过哪些版本 npm info react npm show react npm v react https://registry.npmjs.org/react 这些都能得到某个模块的详细信息 https://registry.npmjs.org/react/v0.14.6 获得某个模块的某个版本的详细信息 npm dist-tags ls express 可以查看到express在npm上发布的最新版本 npm outdated express express模块是否已过时 npm root (-g) 查看当前包，全局包的安装路径 npm config 管理npm的配置路径 npm config set proxy http://proxy.example.com:8080 npm设置代理 npm config get proxy 查看proxy npm config delete proxy 删除proxy npm config list 查看所有配置 npm view moudleName dependencies 查看包的依赖关系 npm install –force 强制重新安装某个模块 二、npm 缓存 npm config get cache 获得缓存的目录对于一些不是很关键的操作（比如npm search或npm view），npm会先查看.cache.json里面的模块最近更新时间，跟当前时间的差距，是不是在可接受的范围之内。如果是的，就不再向远程仓库发出请求，而是直接返回.cache.json的数据 三、npm 安装模块的过程 发出npm install命令 npm 向 registry 查询模块压缩包的网址 下载压缩包，存放在~/.npm目录 解压压缩包到当前项目的node_modules目录 四、npm安装不同版本 npm install sax@latest npm install sax@0.1.1 npm install sax@”&gt;=0.1.0 &lt;0.2.0” 五、包的依赖 dependencies 依赖 1234&quot;dependencies&quot;: &#123; &quot;markdown-it&quot;: &quot;^8.1.0&quot;&#125;/*这个可以说是我们 npm 核心一项内容，依赖管理，这个对象里面的内容就是我们这个项目所依赖的 js 模块包。下面这段代码表示我们依赖了 markdown-it 这个包，版本是 ^8.1.0 ，代表最小依赖版本是 8.1.0 ，如果这个包有更新，那么当我们使用 npm install 命令的时候，npm 会帮我们下载最新的包。当别人引用我们这个包的时候，包内的依赖包也会被下载下来。*/ devDependencies在我们开发的时候会用到的一些包，只是在开发环境中需要用到，但是在别人引用我们包的时候，不会用到这些内容，放在 devDependencies 的包，在别人引用的时候不会被 npm 下载 锁定依赖(^)字符：npm 通过脱字符(^)来限定所安装模块的主版本号，^1.5.1 允许安装版本号大于 1.5.1 但小于 2.0.0 版本的模块。(~)字符: 限定模块的次要版本,~1.5.1 允许安装版本号大于 1.5.1 但小于 1.6.0 版本的模块 六、npm脚本执行 “npm run build-js &amp;&amp; npm run build-css” 两个命令同时执行 package.json name: 包的名字，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格。 description: 包的简要说明。 version: 符合语义化版本识别规范的版本字符串。 keywords: 关键字数组，通常用于搜索。 maintainers: 维护者数组，每个元素要包含 name 、email(可选)、web(可选)字段。 contributors: 贡献者数组，格式与 maintainers 相同。包的作者应该是贡献者数组的第一个元素。 bugs: 提交 bug 的地址，可以是网址或者电子邮件地址。 licenses: 许可证数组，每个元素要包含 type（许可证的名称）和 url（链接到许可证文本的地址）字段。 repositories: 仓库托管地址数组，每个元素要包含 type（仓库的类型，如 git）、URL（仓库的地址）和 path（相对于仓库的路径，可选）字段。 dependencies: 包的依赖，一个关联数组，由包名称和版本号组成。]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux学习]]></title>
    <url>%2Fposts%2F2bbb1d50%2F</url>
    <content type="text"><![CDATA[redux标签（空格分隔）： react Redux运作流程 Redux 三大原则1. 单一数据源传统：传统的 MVC 架构中，我们可以根据需要创建无数个 Model，而 Model 之间可以互相监听、触发事件甚至循环或嵌套触发事件，这些在 Redux 中都是不允许的。Redux：在 Redux 的思想里，一个应用永远只有唯一的数据源.，使用单一数据源的好处在于整个应用状态都保存在一个对象中，这样我们随时可以提取出整个应用的状态进行持久化 2. 状态是只读的在 Redux 中，我们并不会自己用代码来定义一个store。取而代之的是，我们定义一个 reducer，它的功能是根据当前触发的action对当前应用的状态（state）进行迭代，这里我们并没有直接修改应用的状态，而是返回了一份全新的状态。Redux 提供的 createStore方法会根据reducer生成store。最后，我们可以利用 store. dispatch方法来达到修改状态的目的。 3. 状态修改均由纯函数完成在 Redux 里，我们通过定义 reducer 来确定状态的修改，而每一个 reducer 都是纯函数，这意味着它没有副作用，即接受一定的输入，必定会得到一定的输出。这样设计的好处不仅在于reducer里对状态的修改变得简单、纯粹、可测试，更有意思的是，Redux利用每次新返回的状态生成酷炫的时间旅行（time travel）调试方式，让跟踪每一次因为触发action而改变状态的结果成为了可能。 Redux核心API const store = createStore(reducers[, initialState]) store.getState()：获取 store 中当前的状态。 store.dispatch(action)：分发一个action，并返回这个action，这是唯一能改变 store 中数据的方式。 store.subscribe(listener)：注册一个监听者，它在 store 发生变化时被调用。 store.replaceReducer(nextReducer)：更新当前 store 里的 reducer，一般只会在开发模式中调用该方法。 react-reduxreact-redux 提供了一个组件和一个 API 帮助 Redux 和 React 进行绑定，一个是 React 组件 ，一个是 connect()。 接受一个 store 作为props，它是整个 Redux 应用的顶层组件. connect() 提供了在整个 React 应用的任意组件中获取 store 中数据的功能。 middleware 流程 中间件原理分析文章1文章2 Redux与组件1. 容器型组件 容器型组件，意为组件是怎么工作的，更具体一些就是数据是怎么更新的。它不会包含任何Virtual DOM 的修改或组合，也不会包含组件的样式。如果映射到 Flux 上，那么容器型组件就是与store作绑定的组件。如果映射到 Redux 上，那么容器型组件就是使用connect的组件。因此，我们都在这些组件里作了数据更新的定义。 2. 展示型组件 展示型组件，意为组件是怎么渲染的。它包含了Virtual DOM的修改或组合，也可能包含组件的样式。同时，它不依赖任何形式的 store。一般可以写成无状态函数，但实际上展示型组件并不一定都是无状态的组件，因为很多展示型组件里依然存在生命周期方法。 3. 对比 组件类型 LayoutsLayouts 指的是页面布局组件，描述了页面的基本结构，目的是将主框架与页面主体内容分离。它常常是无状态函数，传入主体内容的 children 属性。路由里Layout组件就是设置在最外层 Route 中的 component里。 12345678const Layout = (&#123; children &#125;) =&gt; (&lt;div className=&apos;container&apos;&gt;&lt;Header /&gt;&lt;div className=&quot;content&quot;&gt;&#123;children&#125;&lt;/div&gt;&lt;/div&gt;); ViewsViews 指的是子路由入口组件，描述了子路由入口的基本结构，包含此路由下所有的展示型组件。为了保持子组件的纯净，我们在这一层组件中定义了数据和 action的入口，从这里开始将它们分发到子组件中去。因此Views 就是 Redux 中的容器型组件 1234567891011121314@connect((state) =&gt; &#123;//...&#125;)class HomeView extends Component &#123;render() &#123; const &#123; sth, changeType &#125; = this.props; const cardProps = &#123; sth, changeType &#125;; return ( &lt;div className=&quot;page page-home&quot;&gt; &lt;Card &#123;...cardProps&#125; /&gt; &lt;/div&gt; );&#125;&#125; Components顾名思义，Components就是末级渲染组件，描述了从路由以下的子组件。它们包含具体的业务逻辑和交互，但所有的数据和 action 都是由 Views 传下来的，这也意味着它们是可以完全脱离数据层而存在的展示型组件 12345678910111213141516171819class Card extends Components &#123;constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this);&#125;handleChange(opts) &#123; const &#123; type &#125; = opts; this.props.changeType(type);&#125;render() &#123; const &#123; sth &#125; = this.props; return ( &lt;div className=&quot;mod-card&quot;&gt; &lt;Switch onChange=&#123;this.handleChange&#125;&gt; // ... &lt;/Switch&gt; &#123;sth&#125; &lt;/div&gt;); 例子参考链接阮一峰-Redux基本用法阮一峰-中间件与异步操作阮一峰-React-Redux的用法中间件1中间件2]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建]]></title>
    <url>%2Fposts%2Ff3fb008f%2F</url>
    <content type="text"><![CDATA[为什么要写博客？Why write a blog? 记录工作生活中的心得和体会。如果你在前进过程中学会了回头，那么你会看到更多东西。挤出更多的时间去记录和总结，在需要的时候进行补充和修改，会让问题在你的记忆里愈加深刻。今后遇到更难的问题的时候能够打开思路，或者说有更大的概率去解决。 分享精神。如果说国内的程序员能够有更多的分享精神，那么整个行业的氛围就会受到影响，大家共同的探讨，解决能够相互帮助从而解决更多问题，毕竟一个人的能力是有限的，擅长的方面也各不一样。 一次很好的提升机会。平时解决问题的时候可能考虑进度问题没有更深刻地去理解，但是在写博客的时候，你会不知不觉中对一些内容进行思考，并有可能和评论者一起深入，这些都是难得的机会。同事也提升了文字组织能力和逻辑思维能力。 开始搭建之 hexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 12345$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo server 目录1234567891011.├─ _config.yml # 网站的配置信息├─ package.json # 应用程序的信息├─ scaffolds/ # 模版文件夹├─ source/ # 资源文件夹是存放用户资源的地方│ ├─ _post/ # 文章内容├─ db.json # source解析所得到的├── themes/ # 主题文件夹├── public # 存放的是生成的页面├── .deploy_git # 部署后Markdown 和 HTML 文件├── node_modules # 依赖包 配置文件(_config.yml)123456// 部署deploy: type: git repo: https://github.com/yourGithubName/yourGithubName.github.io branch: master message: 部署成功了，赶紧看看吧 需要在你的 github 上建个仓库，其名是 yourGithubName.github.io 安装$ npm install hexo-deployer-git -S(--save) 命令又叫指令。其实这些在 hexo 官网都有，列出来方便查找 1、init(新建一个网站) 1$ hexo init [folder] 2、new(新建一篇文章) 1$ hexo new [layout] &lt;title&gt; 3、generate(生成静态文件) 12345678$ hexo generate// 简写$ hexo g// 文件生成后立即部署网站$ hexo g -d(--deploy)$ hexo d --generate// 监视文件变动$ hexo g -w(--watch) 4、publish(发表草稿) 1$ hexo publish [layout] &lt;filename&gt; 5、server(启动服务器) 123456789$ hexo server// 简写$ hexo s// 重设端口$ hexo s -p(--port)// 只使用静态文件$ hexo s -s(--static)// 启动日记记录，使用覆盖记录格式$ hexo s -l(--log) Hexo 3.0 把服务器独立成了个别模块，请安装$ npm install hexo-server -S(--save) 6、clean(清除缓存文件 (db.json) 和已生成的静态文件 (public)) 1$ hexo clean 7.list(列出网站资料) 12// type =&gt; page, post, route, tag, category$ hexo list &lt;type&gt; 相关链接 hexo 主题 next 全局配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site #站点信息title: #标题subtitle: #副标题description: #站点描述，给搜索引擎看的author: #作者email: #电子邮箱language: zh-CN #语言# URL #链接格式url: #网址root: / #根目录permalink: :year/:month/:day/:title/ #文章的链接格式tag_dir: tags #标签目录archive_dir: archives #存档目录category_dir: categories #分类目录code_dir: downloads/codepermalink_defaults:# Directory #目录source_dir: source #源文件目录public_dir: public #生成的网页文件目录# Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）titlecase: false #标题转换成大写external_link: true #在新选项卡中打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsehighlight: #语法高亮 enable: true #是否启用 line_number: true #显示行号 tab_replace:# Category &amp; Tag #分类和标签default_category: uncategorized #默认分类category_map:tag_map:# Archives2: 开启分页1: 禁用分页0: 全部禁用archive: 2category: 2tag: 2# Server #本地服务器port: 4000 #端口号server_ip: localhost #IP 地址logger: falselogger_format: dev# Date / Time format #日期时间格式date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/time_format: H:mm:ss# Pagination #分页per_page: 10 #每页文章数，设置成 0 禁用分页pagination_dir: page# Disqus #Disqus评论，替换为多说disqus_shortname:# Extensions #拓展插件theme: landscape-plus #主题exclude_generator:plugins: #插件，例如生成 RSS 和站点地图的- hexo-generator-feed- hexo-generator-sitemap# Deployment #部署，将 lmintlcx 改成用户名deploy: type: git repo: github创库地址.git branch: master 参考资料 知乎参考 博客参考]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react进阶]]></title>
    <url>%2Fposts%2Fc834ce66%2F</url>
    <content type="text"><![CDATA[react-study2标签（空格分隔）： react 一、 事件 react事件写法与html事件写法区别 react： onClick={this.handleClick} 驼峰写法 值可以是任意类型 html: onclick=”handleClick()” 小写 值只能是字符串 react事件机制在 React 底层，主要对合成事件做了两件事：事件委派和自动绑定。 事件委派 react事件绑定并不会把事件处理函数直接绑定到真实的节点上，而是把所有事件绑定到结构的最外层，使用一个统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象；当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率也有很大提升。 自动绑定 1234567891011121314151. bind方式&lt;button onClick=&#123;this.handleClick.bind(this, &apos;test&apos;)&#125;&gt;Test&lt;/button&gt;;2. 双冒号语法&lt;button onClick=&#123;::this.handleClick&#125;&gt;Test&lt;/button&gt;3. 构造器内声明constructor(props) &#123; super(props); this.handleClick = this.handleClick.bind(this);&#125;4. 箭头语法const handleClick = (e) =&gt; &#123; console.log(e);&#125;; react中使用原生事件 12345678910111213141516171819import React, &#123; Component &#125; from &apos;react&apos;;class NativeEventDemo extends Component &#123;componentDidMount() &#123; this.refs.button.addEventListener(&apos;click&apos;, e =&gt; &#123; this.handleClick(e); &#125;);&#125;handleClick(e) &#123; console.log(e);&#125;componentWillUnmount() &#123;//值得注意的是，在 React中使用DOM原生事件时，一定要在组件卸载时手动移除，否则很可能出现内存泄漏的问题。而使用合成事件系统时则不需要，因为 React 内部已经帮你妥善地处理了。 this.refs.button.removeEventListener(&apos;click&apos;);&#125;render() &#123; return &lt;button ref=&quot;button&quot;&gt;Test&lt;/button&gt;;&#125;&#125; react事件与原生事件的对比 事件机制原生事件： 可以分为3个阶段：事件捕获阶段、目标对象本身的事件处理程序调用以及事件冒泡。react事件： 并没有实现事件捕获，仅仅支持了事件冒泡机制 事件类型React 合成事件的事件类型是 JavaScript 原生事件类型的一个子集 事件绑定方式原生： 1234567//dom上绑定&lt;button onclick=&quot;alert(1);&quot;&gt;Test&lt;/button&gt;//属性赋值el.onclick = e =&gt; &#123; console.log(e); &#125;//事件监听函数el.addEventListener(&apos;click&apos;, () =&gt; &#123;&#125;, false);el.attachEvent(&apos;onclick&apos;, () =&gt; &#123;&#125;); 事件对象原生： IE与现代浏览器有差异react: 无差异 二、表单 注意点 textareaJSX 中的 textarea组件与类型为text的input组件的用法很类似。同样有一个 value prop用来表示表单的值，而在HTML中textarea的值则是通过children 来表示的。 selectmultiple={true}表示多选。在HTML的option组件中需要一个selected属性来表示默认选中的列表项，而 React 的处理方式则是通过为select 组件添加 value prop来表示选中的option，在设置了multiple={true}的情况下，该value值是一个数组，表示选中的一组值。这一点与textarea的处理方式一致，这在一定程度上统一了接口。 React 受控组件更新 state 的流程 可以通过在初始 state 中设置表单的默认值。 每当表单的值发生变化时，调用 onChange 事件处理器。 事件处理器通过合成事件对象e拿到改变后的状态，并更新应用的state setState 触发视图的重新渲染，完成表单组件值的更新。 受控组件VS非受控组件 非受控组件的状态并不会受应用状态的控制，应用中也多了局部组件状态，而受控组件的值来自于组件的 state。 三、react中样式 行内样式使用对象写法，且属性使用驼峰表达式表示 123456789const style = &#123; color: &apos;white&apos;, backgroundImage: `url($&#123;imgUrl&#125;)`, // 注意这里大写的 W，会转换成 -webkit-transition WebkitTransition: &apos;all&apos;, // ms 是唯一小写的浏览器前缀 msTransition: &apos;all&apos;,&#125;;const component = &lt;Component style=&#123;style&#125; /&gt;; 数值类的值，不建议写px,默认会加px 四、组件通信 父组件向子组件通信 props 子组件向父组件通信 利用回调函 利用自定义事件机制 跨级嵌套（父子）组件通信（context） React 官方并不建议大量使用context，因为尽管它可以减少逐层传递，但当组件结构复杂的时候，我们并不知道context是从哪里传过来的。Context 就像一个全局变量一样，而全局变量正是导致应用走向混乱的罪魁祸首之一，给组件带来了外部依赖的副作用。在大部分情况下，我们并不推荐使用 context。使用context比较好的场景是真正意义上的全局信息且不会更改，例如界面主题、用户信息等。 跨级非嵌套组件通信（事件） 五、mixin js类似的实现 12345678910111213141516171819const mixin = function(obj, mixins) &#123; const newObj = obj; newObj.prototype = Object.create(obj.prototype); for (let prop in mixins) &#123; if (mixins.hasOwnProperty(prop)) &#123; newObj.prototype[prop] = mixins[prop]; &#125; &#125; return newObj;&#125;const BigMixin = &#123; fly: () =&gt; &#123; console.log(&apos;I can fly&apos;); &#125;&#125;;const Big = function() &#123; console.log(&apos;new big&apos;);&#125;;const FlyBig = mixin(Big, BigMixin); react组件实现mixin 1234567//createClass官方支持引入mixinReact.createClass(&#123; mixins: [PureRenderMixin], render() &#123; return &lt;div&gt;foo&lt;/div&gt;; &#125;&#125;); 普通方法：不能有两个同名的方法 生命周期方法：会将各个模块的生命周期方法叠加在一起顺序执行 六、高阶组件 属性代理: 高阶组件通过被包裹的 React 组件来操作 props。 反向继承: 高阶组件继承于被包裹的 React 组件 1234567891011121314//从功能上，高阶组件一样可以做到像 mixin 对组件的控制，包括控制 props、通过 refs 使用引用、抽象 state 和使用其他元素包裹 WrappedComponent。import React, &#123; Component &#125; from &apos;React&apos;;const MyContainer = (WrappedComponent) =&gt; class extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125;&#125;import React, &#123; Component &#125; from &apos;React&apos;;class MyComponent extends Component &#123;// ...&#125;export default MyContainer(MyComponent); 七、组件性能优化相关文章 PureRender,immutable 1234567891011121314151617181920212223242526import React, &#123; Component &#125; from &apos;react&apos;;import &#123; is &#125; from &apos;immutable&apos;;class App extends Component &#123; //shouldComponentUpdate-&gt;rener-&gt;diff dom shouldComponentUpdate(nextProps, nextState) &#123; const thisProps = this.props || &#123;&#125;; const thisState = this.state || &#123;&#125;; if (Object.keys(thisProps).length !== Object.keys(nextProps).length || Object.keys(thisState).length !== Object.keys(nextState).length) &#123; return true; &#125; for (const key in nextProps) &#123; if (nextProps.hasOwnProperty(key) &amp;&amp; !is(thisProps[key], nextProps[key])) &#123; return true; &#125; &#125; for (const key in nextState) &#123; if (nextState.hasOwnProperty(key) &amp;&amp; !is(thisState[key], nextState[key])) &#123; return true; &#125; &#125; return false; &#125;&#125; key(唯一值) 八、相关demo地址]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react简介]]></title>
    <url>%2Fposts%2Fde3ba3c%2F</url>
    <content type="text"><![CDATA[react-study1标签（空格分隔）： react 一、react简介 专注视图层 可以与其他框架搭配，构建大型应用. 虚拟dom，性能(dom操作性能消耗最大)。 真实页面对应一个 DOM 树。 传统：传统页面的开发模式中，每次需要更新页面时，都要手动操作 DOM 来进行更新 每次数据更新后，重新计算 Virtual DOM，并和上一次生成的 Virtual DOM 做对比，对发生变化的部分做批量更新。React 也提供了直观的 shouldComponentUpdate 生命周期回调，来减少数据变化后不必要的 Virtual DOM 对比过程，以保证性能 函数式编程(react的精髓) jsx语法 二、函数式编程 对比 命令式编程：命令式编程解决的是做什么的问题，执行命令,命令式编程关心解决问题的步骤 函数式编程：是一种”编程范式”（programming paradigm），主要思想是把运算过程尽量写成一系列嵌套的函数调用,函数式编程关心数据的映射 特点 函数是”第一等公民”，指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值 只用”表达式”，不用”语句”“表达式”（expression）是一个单纯的运算过程，总是有返回值；”语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。 没有”副作用”函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。 不修改状态函数式编程只是返回新的值，不修改系统变量。 引用透明引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或”状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。 意义 代码简洁，开发快速函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。 接近自然语言，易于理解（demo） 更方便的代码管理函数式编程不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同。因此，每一个函数都可以被看做独立单元，很有利于进行单元测试（unit testing）和除错（debugging），以及模块化组合。 易于”并发编程” 三、 jsx语法1. jsx的由来 描述虚拟元素可以理解为真实元素的对应，它的构建与更新都是在内存中完成的，并不会真正渲染到 DOM 中去。在 React中创建的虚拟元素可以分为两类，DOM 元素（DOM element）与组件元素（component element），分别对应着原生 DOM 元素与自定义元素，而 JSX 与创建元素的过程有着莫大的关联 dom元素的，react的创建元素类似 123456789101112131415161718&lt;button class=&quot;btn btn-blue&quot;&gt; &lt;em&gt;Confirm&lt;/em&gt;&lt;/button&gt;&#123; type: &apos;button&apos;, props: &#123; className: &apos;btn btn-blue&apos;, children: [&#123; type: &apos;em&apos;, props: &#123; children: &apos;Confirm&apos; &#125; &#125;] &#125;&#125;ps: 在 React 中，到处都是可以复用的元素，这些元素并不是真实的实例，它只是让 React 告诉开发者想要在屏幕上显示什么。我们无法通过方法去调用这些元素，它们只是不可变的描述对象 组件元素，react的创建元素类似 12345678910111213141516171819202122const Button = (&#123; color, text &#125;) =&gt; &#123; return &#123; type: &apos;button&apos;, props: &#123; className: `btn btn-$&#123;color&#125;`, children: &#123; type: &apos;em&apos;, props: &#123; children: text, &#125;, &#125;, &#125;, &#125;;&#125;//创建组件元素的json格式&#123; type: Button, props: &#123; color: &apos;blue&apos;, children: &apos;Confirm&apos; &#125;&#125; 2. jsx的基本语法 基本语法 定义标签时，只允许被一个标签包裹; 标签一定要闭合 元素类型 dom元素： 标签首字母为小写字母 组件元素：标签首字母对应大写首字母 注释 {/ 节点注释 /} 条件注释： 1234567&lt;!--[if IE]&gt;&lt;p&gt;Work in IE browser&lt;/p&gt;&lt;![endif]--&gt;&#123; (!!window.ActiveXObject || &apos;ActiveXObject&apos; in window) ? &lt;p&gt;Work in IE browser&lt;/p&gt; : &apos;&apos;&#125; 元素属性 class 属性改为 className； for 属性改为 htmlFor； 在写自定义属性的时候，都由标准写法改为小驼峰写法 Boolean 属性 省略 Boolean 属性值会导致 JSX 认为 bool 值设为了 true。要传 false 时，必须使用属性表达式 123&lt;Checkbox checked=&#123;true&#125; /&gt;&lt;Checkbox checked /&gt;&lt;Checkbox checked=&#123;false&#125; /&gt; 展开属性 可以使用 ES6 rest/spread 特性来提高效率 12345 const data = &#123; name: &apos;foo&apos;, value: &apos;bar&apos; &#125;; const component = &lt;Component name=&#123;data.name&#125; value=&#123;data.value&#125; /&gt;;可以写成：const data = &#123; name: &apos;foo&apos;, value: &apos;bar&apos; &#125;;const component = &lt;Component &#123;...data&#125; /&gt;; 3. JavaScript 属性表达式1const person = &lt;Person name=&#123;window.isLoggedIn ? window.name : &apos;&apos;&#125; /&gt;; 4.html转义React 会将所有要显示到 DOM 的字符串转义，防止 XSS。 直接使用 UTF-8 字符 使用对应字符的 Unicode 编码查询编码； 使用数组组装 {[‘cc ‘, &copy;, ‘ 2015’]}； 直接插入原始的 HTML React 提供了 dangerouslySetInnerHTML 属性。它的作用就是避免 React 转义字符，在确定必要的情况下可以使用它： 1&lt;div dangerouslySetInnerHTML=&#123;&#123;__html: &apos;cc &amp;copy; 2015&apos;&#125;&#125; /&gt; 四、React组件1. 狭义上的组件，UI组件。说明：组件主要围绕在交互动作上的抽象，针对这些交互动作，利用 JavaScript 操作 DOM 结构或 style 样式来控制。一般会有 3 个部分组件：结构、样式和交互行为 其他知识点Class demo实例 规范标准组件的信息 基本的封装性。尽管说JavaScript没有真正面向对象的方法，但我们还是可以通过实例化的方法来制造对象。 简单的生命周期呈现。最明显的两个方法 constructor 和 destroy，代表了组件的挂载和卸载过程。但除此之外，其他过程（如更新时的生命周期）并没有体现。 明确的数据流动。这里的数据指的是调用组件的参数。一旦确定参数的值，就会解析传进来的参数，根据参数的不同作出不同的响应，从而得到渲染结果。 mvc架构的演变，模板引擎的加入，可以解决view层 弊端：通过改变 class 控制 style 来显示或隐藏。这样的逻辑一旦复杂，就存在大量的 DOM 操作，开发及维护成本相当高。 2. 广义上的组件，带有业务含义和数据的 UI 组件组合这类组件不仅有交互动作，更重要的是有数据与界面之间的交互。 Web Components react组件： React组件基本上由3个部分组成——属性（props）、状态（state）以及生命周期方法说明：React 组件可以接收参数，也可能有自身状态。一旦接收到的参数或自身状态有所改变，React组件就会执行相应的生命周期方法，最后渲染。整个过程完全符合传统组件所定义的组件职责。 对比 React 自定义元素是库自己构建的，与 Web Components 规范并不通用； React 渲染过程包含了模板的概念，即 1.2 节所讲的 JSX； React 组件的实现均在方法与类中，因此可以做到相互隔离，但不包括样式； React 引用方式遵循 ES6 module 标准。 3. react组件创建 React.createClass 123456789101112131415161718const Button = React.createClass(&#123; getDefaultProps() &#123; return &#123; color: &apos;blue&apos;, text: &apos;Confirm&apos;, &#125;; &#125;, render() &#123; const &#123; color, text &#125; = this.props; return ( &lt;button className=&#123;`btn btn-$&#123;color&#125;`&#125;&gt; &lt;em&gt;&#123;text&#125;&lt;/em&gt; &lt;/button&gt; ); &#125;&#125;); ES6 classes 12345678910111213141516171819202122import React, &#123; Component &#125; from &apos;react&apos;;class Button extends Component &#123; constructor(props) &#123; super(props); &#125; static defaultProps = &#123; color: &apos;blue&apos;, text: &apos;Confirm&apos;, &#125;; render() &#123; const &#123; color, text &#125; = this.props; return ( &lt;button className=&#123;`btn btn-$&#123;color&#125;`&#125;&gt; &lt;em&gt;&#123;text&#125;&lt;/em&gt; &lt;/button&gt; ); &#125;&#125; 无状态函数(无状态组件)它不存在 state，也没有生命周期方法,无状态组件。不像上述两种方法在调用时会创建新实例，它创建时始终保持了一个实例，避免了不必要的检查和内存分配，做到了内部优化。 1234567function Button(&#123; color = &apos;blue&apos;, text = &apos;Confirm&apos; &#125;) &#123; return ( &lt;button className=&#123;`btn btn-$&#123;color&#125;`&#125;&gt; &lt;em&gt;&#123;text&#125;&lt;/em&gt; &lt;/button&gt; );&#125; es6与es5差异 五. react数据流 概念 在 React 中，数据是自顶向下单向流动的，即从父组件到子组件。这条原则让组件之间的关系变得简单且可预测。 state 与 props 是 React 组件中最重要的概念。如果顶层组件初始化 props，那么 React会向下遍历整棵组件树，重新尝试渲染所有相关的子组件。而 state只关心每个组件自己内部的状态，这些状态只能在组件内改变。把组件看成一个函数，那么它接受了props作为参数，内部由 state 作为函数的内部参数，返回一个 Virtual DOM 的实现。 state props 六. react生命周期 当组件在挂载或卸载时 当组件接收新的数据时，即组件更新时 组件挂载、卸载1234567891011121314151617181920212223242526272829303132333435import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;class App extends Component &#123; static propTypes = &#123; // 挂载过程 执行一次 &#125;; static defaultProps = &#123; // 挂载过程 执行一次 &#125;; constructor(props) &#123; // 挂载过程 执行一次 super(props); this.state = &#123; // ... &#125;; &#125; componentWillMount() &#123; // if setState 挂载过程 render一次 &#125; componentDidMount() &#123; // if setState 挂载过程 render两次 &#125; componentWillUnmount() &#123; // 卸载过程执行 // 我们常常会执行一些清理方法，如事件回收或是清除定时器。 &#125; render() &#123; return &lt;div&gt;This is a demo.&lt;/div&gt;; &#125;&#125; 数据更新过程说明：更新过程指的是父组件向下传递 props或组件自身执行setState 方法时发生的一系列更新动作。 1234567891011121314151617181920212223import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;class App extends Component &#123; componentWillReceiveProps(nextProps) &#123; // this.setState(&#123;&#125;) &#125; shouldComponentUpdate(nextProps, nextState) &#123; // return true; &#125; componentWillUpdate(nextProps, nextState) &#123; // 不能执行 setState &#125; componentDidUpdate(prevProps, prevState) &#123; // ... &#125; render() &#123; return &lt;div&gt;This is a demo.&lt;/div&gt;; &#125;&#125; state更新 如果组件自身的 state更新了，那么会依次执行shouldComponentUpdate、componentWillUpdate 、render 和 componentDidUpdate。 shouldComponentUpdateshouldComponentUpdate 是一个特别的方法，它接收需要更新的 props 和 state，让开发者增加必要的条件判断，让其在需要时更新，不需要时不更新。因此，当方法返回false的时候，组件不再向下执行生命周期方法。 七. React 与 DOMReactDOM findDOMNode获取dom 12345componentDidUpdatecomponentDidMount() &#123; // this 为当前组件的实例 const dom = ReactDOM.findDOMNode(this); &#125; refs,组件被调用时会新建一个该组件的实例，而refs就会指向这个实例。如果是无状态组件，render会返回null。无状态组件挂载时只是方法调用，没有新建实例.refs 同样支持字符串。对于 DOM 操作，不仅可以使用 findDOMNode 获得该组件 DOM，还可以使用 refs 获得组件内部的 DOM。 12345componentDidMount() &#123;// myComp 是 Comp 的一个实例，因此需要用 findDOMNode 转换为相应的 DOM const myComp = this.refs.myComp; const dom = findDOMNode(myComp); &#125; 八、相关demo地址 相关链接： react官网 阮一峰函数式编程 fed函数式编程 柯里化 webcomponents阮一峰 webcomponents]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
</search>
