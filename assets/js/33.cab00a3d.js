(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{350:function(a,t,e){"use strict";e.r(t);var r=e(28),s=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h3",{attrs:{id:"一、模块加载机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、模块加载机制"}},[a._v("#")]),a._v(" 一、模块加载机制")]),a._v(" "),e("ul",[e("li",[a._v("编译时加载 es6-module")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("import { stat, exists, readFile } from 'fs';\n//上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。\n")])])]),e("ul",[e("li",[a._v("运行时加载 commonjs")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// CommonJS模块\nlet { stat, exists, readFile } = require('fs');\n\n// 等同于\nlet _fs = require('fs');\nlet stat = _fs.stat;\nlet exists = _fs.exists;\nlet readfile = _fs.readfile;\n//上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。\n")])])]),e("h3",{attrs:{id:"二、export-命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、export-命令"}},[a._v("#")]),a._v(" 二、export 命令")]),a._v(" "),e("ul",[e("li",[a._v("常用语法")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("export var firstName = 'Michael';\nexport var lastName = 'Jackson';\nexport var year = 1958;\n//等同于\nvar firstName = 'Michael';\nvar lastName = 'Jackson';\nvar year = 1958;\n\nexport {firstName, lastName, year};\n")])])]),e("ul",[e("li",[a._v("动态绑定")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("export var foo = 'bar';\nsetTimeout(() => foo = 'baz', 500);\n//上面代码输出变量foo，值为bar，500 毫秒之后变成baz。\n//export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。\n")])])]),e("h3",{attrs:{id:"三、import-命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、import-命令"}},[a._v("#")]),a._v(" 三、import 命令")]),a._v(" "),e("ul",[e("li",[a._v("只读属性")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("//import命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。\nimport {a} from './xxx.js'\na = {};\n\na.foo = 'hello'; // 合法操作\n//如果a是一个对象，改写a的属性是允许的。但是不建议\n")])])]),e("ul",[e("li",[a._v("静态执行")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("//由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。\n// 报错\nimport { 'f' + 'oo' } from 'my_module';\n\n// 报错\nlet module = 'my_module';\nimport { foo } from module;\n\n// 报错\nif (x === 1) {\n  import { foo } from 'module1';\n} else {\n  import { foo } from 'module2';\n}\n")])])]),e("ul",[e("li",[a._v("执行次数")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("//如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。\nimport 'lodash';\nimport 'lodash';\n\nimport { foo } from 'my_module';\nimport { bar } from 'my_module';\n// 等同于\nimport { foo, bar } from 'my_module';\n")])])]),e("h3",{attrs:{id:"四、export-default-命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、export-default-命令"}},[a._v("#")]),a._v(" 四、export default 命令")]),a._v(" "),e("ul",[e("li",[a._v("使用,export default 只能使用一次")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// export-default.js\nexport default function () {\n  console.log('foo');\n}\n\nimport customName from './export-default';\ncustomName(); // 'foo'\n//import命令可以为该匿名函数指定任意名字,需要注意的是，这时import命令后面，不使用大括号。\n")])])]),e("ul",[e("li",[a._v("默认输出与正常输出对比")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 第一组\nexport default function crc32() { // 输出\n  // ...\n}\nimport crc32 from 'crc32'; // 输入\n\n// 第二组\nexport function crc32() { // 输出\n  // ...\n};\nimport {crc32} from 'crc32'; // 输入\n")])])]),e("ul",[e("li",[a._v("变量")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 正确\nexport var a = 1;\n\n// 正确\nvar a = 1;\nexport default a;\n//export default a的含义是将变量a的值赋给变量default\n\n// 错误\nexport default var a = 1;\n//正是因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。\n\n// 正确\nexport default 42;\n// 报错\nexport 42;\n//上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定外对接口为default\n\nimport _, { each, each as forEach } from 'lodash';\n//如果想在一条import语句中，同时输入默认方法和其他接口，可以写成下面这样。\n")])])]),e("h3",{attrs:{id:"五、复合写法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五、复合写法"}},[a._v("#")]),a._v(" 五、复合写法")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("export { foo, bar } from 'my_module';\n\n// 可以简单理解为\nimport { foo, bar } from 'my_module';\nexport { foo, bar };\n")])])]),e("h3",{attrs:{id:"六、动态加载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#六、动态加载"}},[a._v("#")]),a._v(" 六、动态加载")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("const path = './' + fileName;\nconst myModual = require(path);\n//因为require是运行时加载模块，import命令无法取代require的动态加载功能。\n")])])]),e("h3",{attrs:{id:"七、script-的-defer-与-async-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#七、script-的-defer-与-async-的区别"}},[a._v("#")]),a._v(" 七、script 的 defer 与 async 的区别")]),a._v(" "),e("p",[a._v("defer 与 async 的区别是：defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer 是“渲染完再执行”，async 是“下载完就执行”。另外，如果有多个 defer 脚本，会按照它们在页面出现的顺序加载，而多个 async 脚本是不能保证加载顺序的。")]),a._v(" "),e("h3",{attrs:{id:"八、es6-模块与-commonjs-模块的差异"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#八、es6-模块与-commonjs-模块的差异"}},[a._v("#")]),a._v(" 八、ES6 模块与 CommonJS 模块的差异")]),a._v(" "),e("ul",[e("li",[a._v("CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用")]),a._v(" "),e("li",[a._v("CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。")])])])}),[],!1,null,null,null);t.default=s.exports}}]);