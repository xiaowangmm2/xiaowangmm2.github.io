<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小王MM的个人博客</title>
  
  <subtitle>从事前端开发的码农一枚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaowangmm2.github.io/"/>
  <updated>2018-06-12T06:13:41.721Z</updated>
  <id>https://xiaowangmm2.github.io/</id>
  
  <author>
    <name>haiyan.wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>visual快捷键</title>
    <link href="https://xiaowangmm2.github.io/posts/81cd6102/"/>
    <id>https://xiaowangmm2.github.io/posts/81cd6102/</id>
    <published>2018-03-30T09:47:34.000Z</published>
    <updated>2018-06-12T06:13:41.721Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、快捷键"><a href="#一、快捷键" class="headerlink" title="一、快捷键"></a>一、快捷键</h3><p>查找            Ctrl+F<br>查找下一个   F3 或者 Ctrl+F3<br>查找上一个   Shift+F3<br>跳到第几行   Ctrl+G<br>向下向上复制本行  Alt + Shift +箭头键(←,↑,↓,→)<br>向下向上移动本行  Alt +箭头键(←,↑,↓,→)<br>从头到尾选择整行  Shift + End<br>从尾到头选择整行  Shift + Home<br>打开命令版        F1 或 Ctrl+Shift+P<br>搜索某个文件      Ctrl+P<br>选择左右匹配项    Ctrl+Shift+L<br>终端弹出          Ctrl+`<br>多光标            ALt</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、快捷键&quot;&gt;&lt;a href=&quot;#一、快捷键&quot; class=&quot;headerlink&quot; title=&quot;一、快捷键&quot;&gt;&lt;/a&gt;一、快捷键&lt;/h3&gt;&lt;p&gt;查找            Ctrl+F&lt;br&gt;查找下一个   F3 或者 Ctrl+F3&lt;br&gt;查找上一个   S
      
    
    </summary>
    
      <category term="工具" scheme="https://xiaowangmm2.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="visual" scheme="https://xiaowangmm2.github.io/tags/visual/"/>
    
  </entry>
  
  <entry>
    <title>npm命令</title>
    <link href="https://xiaowangmm2.github.io/posts/90f8805/"/>
    <id>https://xiaowangmm2.github.io/posts/90f8805/</id>
    <published>2018-03-30T09:38:39.000Z</published>
    <updated>2018-06-12T06:13:41.719Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、命令大全"><a href="#一、命令大全" class="headerlink" title="一、命令大全"></a>一、命令大全</h3><p><a href="https://docs.npmjs.com/#cli" target="_blank" rel="noopener">命令行api，快戳我</a></p><ul><li><p>npm list [-g] 查看所有[<strong>全局安装</strong>]的模块</p><ul><li>(ls、la &amp; ll 可以用作 list 的别名)</li><li>npm list –depth=0 [-g] 查看[全局]安装的包</li></ul></li><li><p>npm list grunt  查看某个模块的版本号</p></li><li>npm uninstall express 卸载express模块。</li><li>npm update express 更新某个模块</li><li>npm info express 可以查看到express在npm上<strong>发布过哪些版本</strong><ul><li>npm info react</li><li>npm show react</li><li>npm v react</li><li><a href="https://registry.npmjs.org/react" target="_blank" rel="noopener">https://registry.npmjs.org/react</a> 这些都能得到某个模块的详细信息</li><li><a href="https://registry.npmjs.org/react/v0.14.6" target="_blank" rel="noopener">https://registry.npmjs.org/react/v0.14.6</a> 获得某个模块的某个版本的详细信息</li></ul></li><li>npm dist-tags ls express 可以查看到express在npm上<strong>发布的最新版本</strong></li><li>npm outdated express express模块是否<strong>已过时</strong></li><li>npm root (-g) 查看当前包，全局包的安装路径</li><li>npm config 管理<strong>npm的配置路径</strong><ul><li>npm config set proxy <a href="http://proxy.example.com:8080" target="_blank" rel="noopener">http://proxy.example.com:8080</a> npm设置代理</li><li>npm config get proxy 查看proxy</li><li>npm config delete proxy 删除proxy</li><li>npm config list 查看所有配置</li></ul></li><li>npm view moudleName dependencies 查看包的<strong>依赖关系</strong></li><li>npm install <packagename> –force 强制<strong>重新安装</strong>某个模块</packagename></li></ul><h3 id="二、npm-缓存"><a href="#二、npm-缓存" class="headerlink" title="二、npm 缓存"></a>二、npm 缓存</h3><ul><li>npm config get cache 获得缓存的目录<br>对于一些不是很关键的操作（比如npm search或npm view），npm会先查看.cache.json里面的模块最近更新时间，跟当前时间的差距，是不是在<strong>可接受的范围之内</strong>。如果是的，就不再向远程仓库发出请求，而是直接返回.cache.json的数据</li></ul><h3 id="三、npm-安装模块的过程"><a href="#三、npm-安装模块的过程" class="headerlink" title="三、npm 安装模块的过程"></a>三、npm 安装模块的过程</h3><ol><li>发出npm install命令</li><li>npm 向 registry 查询模块压缩包的网址</li><li>下载压缩包，存放在~/.npm目录</li><li>解压压缩包到当前项目的node_modules目录</li></ol><h3 id="四、npm安装不同版本"><a href="#四、npm安装不同版本" class="headerlink" title="四、npm安装不同版本"></a>四、npm安装不同版本</h3><ol><li>npm install sax@latest</li><li>npm install <a href="mailto:sax@0.1.1" target="_blank" rel="noopener">sax@0.1.1</a></li><li>npm install sax@”&gt;=0.1.0 &lt;0.2.0”</li></ol><h3 id="五、包的依赖"><a href="#五、包的依赖" class="headerlink" title="五、包的依赖"></a>五、包的依赖</h3><ul><li><p>dependencies 依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;markdown-it&quot;: &quot;^8.1.0&quot;</span><br><span class="line">&#125;</span><br><span class="line">/*这个可以说是我们 npm 核心一项内容，依赖管理，这个对象里面的内容就是我们这个项目所依赖的 js 模块包。下面这段代码表示我们依赖了 markdown-it 这个包，版本是 ^8.1.0 ，代表最小依赖版本是 8.1.0 ，如果这个包有更新，那么当我们使用 npm install 命令的时候，npm 会帮我们下载最新的包。当别人引用我们这个包的时候，包内的依赖包也会被下载下来。*/</span><br></pre></td></tr></table></figure></li><li><p>devDependencies<br>在我们开发的时候会用到的一些包，只是在开发环境中需要用到，但是在别人引用我们包的时候，不会用到这些内容，放在 devDependencies 的包，在别人引用的时候不会被 npm 下载</p></li><li><p>锁定依赖<br>(^)字符：npm 通过脱字符(^)来限定所安装模块的主版本号，^1.5.1 允许安装版本号大于 1.5.1 但小于 2.0.0 版本的模块。<br>(~)字符: 限定模块的次要版本,~1.5.1 允许安装版本号大于 1.5.1 但小于 1.6.0 版本的模块</p></li></ul><h3 id="六、npm脚本执行"><a href="#六、npm脚本执行" class="headerlink" title="六、npm脚本执行"></a>六、npm脚本执行</h3><ul><li>“npm run build-js &amp;&amp; npm run build-css” 两个命令同时执行</li></ul><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><ol><li>name: 包的名字，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格。</li><li>description: 包的简要说明。</li><li>version: 符合语义化版本识别规范的版本字符串。</li><li>keywords: 关键字数组，通常用于搜索。</li><li>maintainers: 维护者数组，每个元素要包含 name 、email(可选)、web(可选)字段。</li><li>contributors: 贡献者数组，格式与 maintainers 相同。包的作者应该是贡献者数组的第一个元素。</li><li>bugs: 提交 bug 的地址，可以是网址或者电子邮件地址。</li><li>licenses: 许可证数组，每个元素要包含 type（许可证的名称）和 url（链接到许可证文本的地址）字段。</li><li>repositories: 仓库托管地址数组，每个元素要包含 type（仓库的类型，如 git）、URL（仓库的地址）和 path（相对于仓库的路径，可选）字段。</li><li>dependencies: 包的依赖，一个关联数组，由包名称和版本号组成。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、命令大全&quot;&gt;&lt;a href=&quot;#一、命令大全&quot; class=&quot;headerlink&quot; title=&quot;一、命令大全&quot;&gt;&lt;/a&gt;一、命令大全&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://docs.npmjs.com/#cli&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
      <category term="npm" scheme="https://xiaowangmm2.github.io/categories/npm/"/>
    
    
      <category term="npm" scheme="https://xiaowangmm2.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>redux学习</title>
    <link href="https://xiaowangmm2.github.io/posts/2bbb1d50/"/>
    <id>https://xiaowangmm2.github.io/posts/2bbb1d50/</id>
    <published>2017-10-08T06:00:18.000Z</published>
    <updated>2018-06-12T06:13:41.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h1><p>标签（空格分隔）： react</p><hr><h2 id="Redux运作流程"><a href="#Redux运作流程" class="headerlink" title="Redux运作流程"></a>Redux运作流程</h2><p><img src="http://chuantu.biz/t6/83/1507358482x1944864576.png" alt="流程"></p><h2 id="Redux-三大原则"><a href="#Redux-三大原则" class="headerlink" title="Redux 三大原则"></a>Redux 三大原则</h2><h3 id="1-单一数据源"><a href="#1-单一数据源" class="headerlink" title="1. 单一数据源"></a>1. 单一数据源</h3><p><strong>传统：</strong><br>传统的 MVC 架构中，我们可以根据需要创建无数个 Model，而 Model 之间可以互相监听、触发事件甚至循环或嵌套触发事件，这些在 Redux 中都是不允许的。<br><strong>Redux：</strong><br>在 Redux 的思想里，一个应用永远只有唯一的数据源.，使用单一数据源的好处在于整个应用状态都保存在一个对象中，这样我们随时可以提取出整个应用的状态进行持久化</p><h3 id="2-状态是只读的"><a href="#2-状态是只读的" class="headerlink" title="2. 状态是只读的"></a>2. 状态是只读的</h3><p>在 Redux 中，我们并不会自己用代码来定义一个store。取而代之的是，我们定义一个 reducer，它的功能是根据当前触发的action对当前应用的状态（state）进行迭代，这里我们并没有直接修改应用的状态，而是返回了一份全新的状态。<br>Redux 提供的 createStore方法会根据reducer生成store。最后，我们可以利用 store. dispatch方法来达到修改状态的目的。</p><h3 id="3-状态修改均由纯函数完成"><a href="#3-状态修改均由纯函数完成" class="headerlink" title="3. 状态修改均由纯函数完成"></a>3. 状态修改均由纯函数完成</h3><p>在 Redux 里，我们通过定义 reducer 来确定状态的修改，而每一个 reducer 都是纯函数，这意味着它没有副作用，即接受一定的输入，必定会得到一定的输出。<br>这样设计的好处不仅在于reducer里对状态的修改变得简单、纯粹、可测试，更有意思的是，Redux利用每次新返回的状态生成酷炫的时间旅行（time travel）调试方式，让跟踪每一次因为触发action而改变状态的结果成为了可能。<br><a id="more"></a></p><h2 id="Redux核心API"><a href="#Redux核心API" class="headerlink" title="Redux核心API"></a>Redux核心API</h2><ol><li>const store = createStore(reducers[, initialState])</li><li>store.getState()：获取 store 中当前的状态。</li><li>store.dispatch(action)：分发一个action，并返回这个action，这是唯一能改变 store 中数据的方式。</li><li>store.subscribe(listener)：注册一个监听者，它在 store 发生变化时被调用。</li><li>store.replaceReducer(nextReducer)：更新当前 store 里的 reducer，一般只会在开发模式中调用该方法。</li></ol><h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>react-redux 提供了一个组件和一个 API 帮助 Redux 和 React 进行绑定，一个是 React 组件<provider> ，一个是 connect()。</provider></p><ol><li><provider> 接受一个 store 作为props，它是整个 Redux 应用的顶层组件.</provider></li><li>connect() 提供了在整个 React 应用的任意组件中获取 store 中数据的功能。</li></ol><h2 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h2><ol><li><p>流程<br><img src="http://chuantu.biz/t6/83/1507359828x2890149518.png" alt="同步"><br><img src="http://chuantu.biz/t6/83/1507359863x2890149518.png" alt="异步"></p></li><li><p>中间件原理分析<br><a href="https://zhuanlan.zhihu.com/p/21391101" target="_blank" rel="noopener">文章1</a><br><a href="https://zhuanlan.zhihu.com/p/20597452" target="_blank" rel="noopener">文章2</a></p></li></ol><h2 id="Redux与组件"><a href="#Redux与组件" class="headerlink" title="Redux与组件"></a>Redux与组件</h2><h3 id="1-容器型组件"><a href="#1-容器型组件" class="headerlink" title="1. 容器型组件"></a>1. 容器型组件</h3><blockquote><p>容器型组件，意为组件是怎么工作的，更具体一些就是数据是怎么更新的。它不会包含任何Virtual DOM 的修改或组合，也不会包含组件的样式。<br>如果映射到 Flux 上，那么容器型组件就是与store作绑定的组件。如果映射到 Redux 上，那么容器型组件就是使用connect的组件。因此，我们都在这些组件里作了数据更新的定义。</p></blockquote><h3 id="2-展示型组件"><a href="#2-展示型组件" class="headerlink" title="2. 展示型组件"></a>2. 展示型组件</h3><blockquote><p>展示型组件，意为组件是怎么渲染的。它包含了Virtual DOM的修改或组合，也可能包含组件的样式。同时，它不依赖任何形式的 store。一般可以写成无状态函数，但实际上展示型组件并不一定都是无状态的组件，因为很多展示型组件里依然存在生命周期方法。</p></blockquote><h3 id="3-对比"><a href="#3-对比" class="headerlink" title="3. 对比"></a>3. 对比</h3><p><img src="http://chuantu.biz/t6/73/1506741269x1944864576.png" alt="对比"></p><ol start="4"><li>组件类型</li></ol><ul><li><p>Layouts<br>Layouts 指的是页面布局组件，描述了页面的基本结构，目的是将主框架与页面主体内容分离。它常常是无状态函数，传入主体内容的 children 属性。路由里Layout组件就是设置在最外层 Route 中的 component里。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Layout = (&#123; children &#125;) =&gt; (</span><br><span class="line">&lt;div className=&apos;container&apos;&gt;</span><br><span class="line">&lt;Header /&gt;</span><br><span class="line">&lt;div className=&quot;content&quot;&gt;</span><br><span class="line">&#123;children&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>Views<br>Views 指的是子路由入口组件，描述了子路由入口的基本结构，包含此路由下所有的展示型组件。为了保持子组件的纯净，我们在这一层组件中定义了数据和 action的入口，从这里开始将它们分发到子组件中去。因此<strong>Views 就是 Redux 中的容器型组件</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@connect((state) =&gt; &#123;</span><br><span class="line">//...</span><br><span class="line">&#125;)</span><br><span class="line">class HomeView extends Component &#123;</span><br><span class="line">render() &#123;</span><br><span class="line">    const &#123; sth, changeType &#125; = this.props;</span><br><span class="line">    const cardProps = &#123; sth, changeType &#125;;</span><br><span class="line">    return (</span><br><span class="line">    &lt;div className=&quot;page page-home&quot;&gt;</span><br><span class="line">        &lt;Card &#123;...cardProps&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Components<br>顾名思义，Components就是末级渲染组件，描述了从路由以下的子组件。它们包含具体的业务逻辑和交互，但所有的数据和 action 都是由 Views 传下来的，这也意味着它们是可以完全脱离数据层而存在的展示型组件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Card extends Components &#123;</span><br><span class="line">constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">&#125;</span><br><span class="line">handleChange(opts) &#123;</span><br><span class="line">    const &#123; type &#125; = opts;</span><br><span class="line">    this.props.changeType(type);</span><br><span class="line">&#125;</span><br><span class="line">render() &#123;</span><br><span class="line">    const &#123; sth &#125; = this.props;</span><br><span class="line">    return (</span><br><span class="line">    &lt;div className=&quot;mod-card&quot;&gt;</span><br><span class="line">    &lt;Switch onChange=&#123;this.handleChange&#125;&gt;</span><br><span class="line">    // ...</span><br><span class="line">    &lt;/Switch&gt;</span><br><span class="line">    &#123;sth&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a><a href="https://github.com/xiaowangmm2/react-demo/tree/master/react-redux-router" target="_blank" rel="noopener">例子</a></h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="noopener">阮一峰-Redux基本用法</a><br><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html" target="_blank" rel="noopener">阮一峰-中间件与异步操作</a><br><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html" target="_blank" rel="noopener">阮一峰-React-Redux的用法</a><br><a href="https://zhuanlan.zhihu.com/p/21391101" target="_blank" rel="noopener">中间件1</a><br><a href="https://zhuanlan.zhihu.com/p/20597452" target="_blank" rel="noopener">中间件2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;redux&quot;&gt;&lt;a href=&quot;#redux&quot; class=&quot;headerlink&quot; title=&quot;redux&quot;&gt;&lt;/a&gt;redux&lt;/h1&gt;&lt;p&gt;标签（空格分隔）： react&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Redux运作流程&quot;&gt;&lt;a href=&quot;#Redux运作流程&quot; class=&quot;headerlink&quot; title=&quot;Redux运作流程&quot;&gt;&lt;/a&gt;Redux运作流程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://chuantu.biz/t6/83/1507358482x1944864576.png&quot; alt=&quot;流程&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Redux-三大原则&quot;&gt;&lt;a href=&quot;#Redux-三大原则&quot; class=&quot;headerlink&quot; title=&quot;Redux 三大原则&quot;&gt;&lt;/a&gt;Redux 三大原则&lt;/h2&gt;&lt;h3 id=&quot;1-单一数据源&quot;&gt;&lt;a href=&quot;#1-单一数据源&quot; class=&quot;headerlink&quot; title=&quot;1. 单一数据源&quot;&gt;&lt;/a&gt;1. 单一数据源&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;传统：&lt;/strong&gt;&lt;br&gt;传统的 MVC 架构中，我们可以根据需要创建无数个 Model，而 Model 之间可以互相监听、触发事件甚至循环或嵌套触发事件，这些在 Redux 中都是不允许的。&lt;br&gt;&lt;strong&gt;Redux：&lt;/strong&gt;&lt;br&gt;在 Redux 的思想里，一个应用永远只有唯一的数据源.，使用单一数据源的好处在于整个应用状态都保存在一个对象中，这样我们随时可以提取出整个应用的状态进行持久化&lt;/p&gt;
&lt;h3 id=&quot;2-状态是只读的&quot;&gt;&lt;a href=&quot;#2-状态是只读的&quot; class=&quot;headerlink&quot; title=&quot;2. 状态是只读的&quot;&gt;&lt;/a&gt;2. 状态是只读的&lt;/h3&gt;&lt;p&gt;在 Redux 中，我们并不会自己用代码来定义一个store。取而代之的是，我们定义一个 reducer，它的功能是根据当前触发的action对当前应用的状态（state）进行迭代，这里我们并没有直接修改应用的状态，而是返回了一份全新的状态。&lt;br&gt;Redux 提供的 createStore方法会根据reducer生成store。最后，我们可以利用 store. dispatch方法来达到修改状态的目的。&lt;/p&gt;
&lt;h3 id=&quot;3-状态修改均由纯函数完成&quot;&gt;&lt;a href=&quot;#3-状态修改均由纯函数完成&quot; class=&quot;headerlink&quot; title=&quot;3. 状态修改均由纯函数完成&quot;&gt;&lt;/a&gt;3. 状态修改均由纯函数完成&lt;/h3&gt;&lt;p&gt;在 Redux 里，我们通过定义 reducer 来确定状态的修改，而每一个 reducer 都是纯函数，这意味着它没有副作用，即接受一定的输入，必定会得到一定的输出。&lt;br&gt;这样设计的好处不仅在于reducer里对状态的修改变得简单、纯粹、可测试，更有意思的是，Redux利用每次新返回的状态生成酷炫的时间旅行（time travel）调试方式，让跟踪每一次因为触发action而改变状态的结果成为了可能。&lt;br&gt;
    
    </summary>
    
      <category term="react" scheme="https://xiaowangmm2.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://xiaowangmm2.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建</title>
    <link href="https://xiaowangmm2.github.io/posts/f3fb008f/"/>
    <id>https://xiaowangmm2.github.io/posts/f3fb008f/</id>
    <published>2017-10-08T03:04:58.000Z</published>
    <updated>2019-07-25T07:39:00.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要写博客？Why-write-a-blog"><a href="#为什么要写博客？Why-write-a-blog" class="headerlink" title="为什么要写博客？Why write a blog?"></a>为什么要写博客？Why write a blog?</h2><ul><li>记录工作生活中的心得和体会。<br>如果你在前进过程中学会了回头，那么你会看到更多东西。挤出更多的时间去记录和总结，在需要的时候进行补充和修改，会让问题在你的记忆里愈加深刻。今后遇到更难的问题的时候能够打开思路，或者说有更大的概率去解决。</li></ul><a id="more"></a><ul><li><p>分享精神。<br>如果说国内的程序员能够有更多的分享精神，那么整个行业的氛围就会受到影响，大家共同的探讨，解决能够相互帮助从而解决更多问题，毕竟一个人的能力是有限的，擅长的方面也各不一样。</p></li><li><p>一次很好的提升机会。<br>平时解决问题的时候可能考虑进度问题没有更深刻地去理解，但是在写博客的时候，你会不知不觉中对一些内容进行思考，并有可能和评论者一起深入，这些都是难得的机会。同事也提升了文字组织能力和逻辑思维能力。</p></li></ul><h2 id="开始搭建之-hexo"><a href="#开始搭建之-hexo" class="headerlink" title="开始搭建之 hexo"></a>开始搭建之 hexo</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ cd blog</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├─ _config.yml      # 网站的配置信息</span><br><span class="line">├─ package.json     # 应用程序的信息</span><br><span class="line">├─ scaffolds/       # 模版文件夹</span><br><span class="line">├─ source/          # 资源文件夹是存放用户资源的地方</span><br><span class="line">│   ├─ _post/       # 文章内容</span><br><span class="line">├─ db.json          # source解析所得到的</span><br><span class="line">├── themes/         # 主题文件夹</span><br><span class="line">├── public          # 存放的是生成的页面</span><br><span class="line">├── .deploy_git     # 部署后Markdown 和 HTML 文件</span><br><span class="line">├── node_modules    # 依赖包</span><br></pre></td></tr></table></figure><h4 id="配置文件-config-yml"><a href="#配置文件-config-yml" class="headerlink" title="配置文件(_config.yml)"></a>配置文件(_config.yml)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 部署</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/yourGithubName/yourGithubName.github.io</span><br><span class="line">  branch: master</span><br><span class="line">  message: 部署成功了，赶紧看看吧</span><br></pre></td></tr></table></figure><ul><li>需要在你的 github 上建个仓库，其名是 yourGithubName.github.io</li><li>安装<code>$ npm install hexo-deployer-git -S(--save)</code></li></ul><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>又叫指令。其实这些在 hexo 官网都有，列出来方便查找</p><p>1、init(新建一个网站)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure><p>2、new(新建一篇文章)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>3、generate(生成静态文件)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">// 简写</span><br><span class="line">$ hexo g</span><br><span class="line">// 文件生成后立即部署网站</span><br><span class="line">$ hexo g -d(--deploy)</span><br><span class="line">$ hexo d --generate</span><br><span class="line">// 监视文件变动</span><br><span class="line">$ hexo g -w(--watch)</span><br></pre></td></tr></table></figure><p>4、publish(发表草稿)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>5、server(启动服务器)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">// 简写</span><br><span class="line">$ hexo s</span><br><span class="line">// 重设端口</span><br><span class="line">$ hexo s -p(--port)</span><br><span class="line">// 只使用静态文件</span><br><span class="line">$ hexo s -s(--static)</span><br><span class="line">// 启动日记记录，使用覆盖记录格式</span><br><span class="line">$ hexo s -l(--log)</span><br></pre></td></tr></table></figure><ul><li>Hexo 3.0 把服务器独立成了个别模块，请安装<code>$ npm install hexo-server -S(--save)</code></li></ul><p>6、clean(清除缓存文件 (db.json) 和已生成的静态文件 (public))</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>7.list(列出网站资料)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// type =&gt; page, post, route, tag, category</span><br><span class="line">$ hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li><a href="https://hexo.io" target="_blank" rel="noopener">hexo</a></li><li><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">主题 next</a></li></ul><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: http://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"># Site #站点信息</span><br><span class="line">title:  #标题</span><br><span class="line">subtitle:  #副标题</span><br><span class="line">description:  #站点描述，给搜索引擎看的</span><br><span class="line">author:  #作者</span><br><span class="line">email:  #电子邮箱</span><br><span class="line">language: zh-CN #语言</span><br><span class="line"># URL #链接格式</span><br><span class="line">url:  #网址</span><br><span class="line">root: / #根目录</span><br><span class="line">permalink: :year/:month/:day/:title/ #文章的链接格式</span><br><span class="line">tag_dir: tags #标签目录</span><br><span class="line">archive_dir: archives #存档目录</span><br><span class="line">category_dir: categories #分类目录</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">permalink_defaults:</span><br><span class="line"># Directory #目录</span><br><span class="line">source_dir: source #源文件目录</span><br><span class="line">public_dir: public #生成的网页文件目录</span><br><span class="line"># Writing #写作</span><br><span class="line">new_post_name: :title.md #新文章标题</span><br><span class="line">default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）</span><br><span class="line">titlecase: false #标题转换成大写</span><br><span class="line">external_link: true #在新选项卡中打开连接</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">highlight: #语法高亮</span><br><span class="line">  enable: true #是否启用</span><br><span class="line">  line_number: true #显示行号</span><br><span class="line">  tab_replace:</span><br><span class="line"># Category &amp; Tag #分类和标签</span><br><span class="line">default_category: uncategorized #默认分类</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"># Archives</span><br><span class="line">2: 开启分页</span><br><span class="line">1: 禁用分页</span><br><span class="line">0: 全部禁用</span><br><span class="line">archive: 2</span><br><span class="line">category: 2</span><br><span class="line">tag: 2</span><br><span class="line"># Server #本地服务器</span><br><span class="line">port: 4000 #端口号</span><br><span class="line">server_ip: localhost #IP 地址</span><br><span class="line">logger: false</span><br><span class="line">logger_format: dev</span><br><span class="line"># Date / Time format #日期时间格式</span><br><span class="line">date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">time_format: H:mm:ss</span><br><span class="line"># Pagination #分页</span><br><span class="line">per_page: 10 #每页文章数，设置成 0 禁用分页</span><br><span class="line">pagination_dir: page</span><br><span class="line"># Disqus #Disqus评论，替换为多说</span><br><span class="line">disqus_shortname:</span><br><span class="line"># Extensions #拓展插件</span><br><span class="line">theme: landscape-plus #主题</span><br><span class="line">exclude_generator:</span><br><span class="line">plugins: #插件，例如生成 RSS 和站点地图的</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">- hexo-generator-sitemap</span><br><span class="line"># Deployment #部署，将 lmintlcx 改成用户名</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: github创库地址.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">知乎参考</a></li><li><a href="https://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">博客参考</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要写博客？Why-write-a-blog&quot;&gt;&lt;a href=&quot;#为什么要写博客？Why-write-a-blog&quot; class=&quot;headerlink&quot; title=&quot;为什么要写博客？Why write a blog?&quot;&gt;&lt;/a&gt;为什么要写博客？Why write a blog?&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;记录工作生活中的心得和体会。&lt;br&gt;如果你在前进过程中学会了回头，那么你会看到更多东西。挤出更多的时间去记录和总结，在需要的时候进行补充和修改，会让问题在你的记忆里愈加深刻。今后遇到更难的问题的时候能够打开思路，或者说有更大的概率去解决。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://xiaowangmm2.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://xiaowangmm2.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>react进阶</title>
    <link href="https://xiaowangmm2.github.io/posts/c834ce66/"/>
    <id>https://xiaowangmm2.github.io/posts/c834ce66/</id>
    <published>2017-09-22T06:13:35.000Z</published>
    <updated>2018-06-12T06:13:41.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react-study2"><a href="#react-study2" class="headerlink" title="react-study2"></a>react-study2</h1><p>标签（空格分隔）： react</p><hr><h2 id="一、-事件"><a href="#一、-事件" class="headerlink" title="一、 事件"></a>一、 事件</h2><ol><li>react事件写法与html事件写法区别</li></ol><ul><li>react： onClick={this.handleClick} 驼峰写法 值可以是任意类型</li><li>html: onclick=”handleClick()” 小写  值只能是字符串</li></ul><ol start="2"><li>react事件机制<br>在 React 底层，主要对合成事件做了两件事：事件委派和自动绑定。</li></ol><ul><li><p>事件委派</p><blockquote><p>react事件绑定并不会把事件处理函数直接绑定到真实的节点上，而是把所有事件绑定到<strong>结构的最外层</strong>，使用一个统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象；当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率也有很大提升。</p></blockquote></li><li><p>自动绑定</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. bind方式</span><br><span class="line">&lt;button onClick=&#123;this.handleClick.bind(this, &apos;test&apos;)&#125;&gt;Test&lt;/button&gt;;</span><br><span class="line"></span><br><span class="line">2. 双冒号语法</span><br><span class="line">&lt;button onClick=&#123;::this.handleClick&#125;&gt;Test&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">3. 构造器内声明</span><br><span class="line">constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleClick = this.handleClick.bind(this);</span><br><span class="line">&#125;</span><br><span class="line">4. 箭头语法</span><br><span class="line">const handleClick = (e) =&gt; &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><p>react中使用原生事件</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">class NativeEventDemo extends Component &#123;</span><br><span class="line"></span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">    this.refs.button.addEventListener(&apos;click&apos;, e =&gt; &#123;</span><br><span class="line">        this.handleClick(e);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">handleClick(e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">&#125;</span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">//值得注意的是，在 React中使用DOM原生事件时，一定要在组件卸载时手动移除，否则很可能出现内存泄漏的问题。而使用合成事件系统时则不需要，因为 React 内部已经帮你妥善地处理了。</span><br><span class="line">    this.refs.button.removeEventListener(&apos;click&apos;);</span><br><span class="line">&#125;</span><br><span class="line">render() &#123;</span><br><span class="line">    return &lt;button ref=&quot;button&quot;&gt;Test&lt;/button&gt;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>react事件与原生事件的对比</p></li></ol><ul><li><p>事件机制<br>原生事件： 可以分为3个阶段：事件捕获阶段、目标对象本身的事件处理程序调用以及事件冒泡。<br>react事件： 并没有实现事件捕获，仅仅支持了事件冒泡机制</p></li><li><p>事件类型<br>React 合成事件的事件类型是 JavaScript 原生事件类型的一个子集</p></li><li><p>事件绑定方式<br>原生：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//dom上绑定</span><br><span class="line">&lt;button onclick=&quot;alert(1);&quot;&gt;Test&lt;/button&gt;</span><br><span class="line">//属性赋值</span><br><span class="line">el.onclick = e =&gt; &#123; console.log(e); &#125;</span><br><span class="line">//事件监听函数</span><br><span class="line">el.addEventListener(&apos;click&apos;, () =&gt; &#123;&#125;, false);</span><br><span class="line">el.attachEvent(&apos;onclick&apos;, () =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure></li><li><p>事件对象<br>原生： IE与现代浏览器有差异<br>react: 无差异</p></li></ul><a id="more"></a><h2 id="二、表单"><a href="#二、表单" class="headerlink" title="二、表单"></a>二、表单</h2><ol><li>注意点</li></ol><ul><li>textarea<br>JSX 中的 textarea组件与类型为text的input组件的用法很类似。同样有一个 <strong>value prop</strong>用来表示表单的值，而在HTML中textarea的值则是通过<strong>children</strong> 来表示的。</li><li>select<br>multiple={true}表示多选。在HTML的option组件中需要一个<strong>selected</strong>属性来表示默认选中的列表项，而 React 的处理方式则是通过为select 组件添加 <strong>value prop</strong>来表示选中的option，在设置了multiple={true}的情况下，该value值是一个数组，表示选中的一组值。这一点与textarea的处理方式一致，这在一定程度上统一了接口。</li></ul><ol start="2"><li>React 受控组件更新 state 的流程</li></ol><ul><li>可以通过在初始 state 中设置表单的默认值。</li><li>每当表单的值发生变化时，调用 onChange 事件处理器。</li><li>事件处理器通过合成事件对象e拿到改变后的状态，并更新应用的state</li><li>setState 触发视图的重新渲染，完成表单组件值的更新。</li></ul><ol start="3"><li>受控组件VS非受控组件</li></ol><ul><li>非受控组件的状态并不会受应用状态的控制，应用中也多了局部组<br>件状态，而受控组件的值来自于组件的 state。</li></ul><h2 id="三、react中样式"><a href="#三、react中样式" class="headerlink" title="三、react中样式"></a>三、react中样式</h2><ol><li>行内样式使用对象写法，且属性使用驼峰表达式表示</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const style = &#123;</span><br><span class="line">    color: &apos;white&apos;,</span><br><span class="line">    backgroundImage: `url($&#123;imgUrl&#125;)`,</span><br><span class="line">    // 注意这里大写的 W，会转换成 -webkit-transition</span><br><span class="line">    WebkitTransition: &apos;all&apos;,</span><br><span class="line">    // ms 是唯一小写的浏览器前缀</span><br><span class="line">    msTransition: &apos;all&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">const component = &lt;Component style=&#123;style&#125; /&gt;;</span><br></pre></td></tr></table></figure><ol start="2"><li>数值类的值，不建议写px,默认会加px</li></ol><h2 id="四、组件通信"><a href="#四、组件通信" class="headerlink" title="四、组件通信"></a>四、组件通信</h2><ol><li>父组件向子组件通信</li></ol><ul><li>props</li></ul><ol start="2"><li>子组件向父组件通信</li></ol><ul><li>利用回调函</li><li>利用自定义事件机制</li></ul><ol start="3"><li>跨级嵌套<strong>（父子）</strong>组件通信（context）<blockquote><p>React 官方并不建议大量使用context，因为尽管它可以减少逐层传递，但当组件结构复杂的时候，我们并不知道context是从哪里传过来的。Context 就像一个全局变量一样，而全局变量正是导致应用走向混乱的罪魁祸首之一，给组件带来了外部依赖的副作用。在大部分情况下，我们并不推荐使用 context。使用context比较好的场景是真正意义上的全局信息且不会更改，例如界面主题、用户信息等。</p></blockquote></li><li>跨级非嵌套组件通信（事件）</li></ol><h2 id="五、mixin"><a href="#五、mixin" class="headerlink" title="五、mixin"></a>五、mixin</h2><ol><li>js类似的实现</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const mixin = function(obj, mixins) &#123;</span><br><span class="line">    const newObj = obj;</span><br><span class="line">    newObj.prototype = Object.create(obj.prototype);</span><br><span class="line">    for (let prop in mixins) &#123;</span><br><span class="line">        if (mixins.hasOwnProperty(prop)) &#123;</span><br><span class="line">            newObj.prototype[prop] = mixins[prop];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newObj;</span><br><span class="line">&#125;</span><br><span class="line">const BigMixin = &#123;</span><br><span class="line">    fly: () =&gt; &#123;</span><br><span class="line">    console.log(&apos;I can fly&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const Big = function() &#123;</span><br><span class="line">    console.log(&apos;new big&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">const FlyBig = mixin(Big, BigMixin);</span><br></pre></td></tr></table></figure><ol start="2"><li>react组件实现mixin</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//createClass官方支持引入mixin</span><br><span class="line">React.createClass(&#123;</span><br><span class="line">    mixins: [PureRenderMixin],</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;foo&lt;/div&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>普通方法：不能有两个同名的方法</li><li>生命周期方法：会将各个模块的生命周期方法叠加在一起顺序执行</li></ul><h2 id="六、高阶组件"><a href="#六、高阶组件" class="headerlink" title="六、高阶组件"></a>六、高阶组件</h2><ol><li><a href="#prop">属性代理</a>: 高阶组件通过被包裹的 React 组件来操作 props。</li><li>反向继承: 高阶组件继承于被包裹的 React 组件</li></ol><p><span id="prop"></span><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//从功能上，高阶组件一样可以做到像 mixin 对组件的控制，包括控制 props、通过 refs 使用引用、抽象 state 和使用其他元素包裹 WrappedComponent。</span><br><span class="line">import React, &#123; Component &#125; from &apos;React&apos;;</span><br><span class="line">const MyContainer = (WrappedComponent) =&gt;</span><br><span class="line">    class extends Component &#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return &lt;WrappedComponent &#123;...this.props&#125; /&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">import React, &#123; Component &#125; from &apos;React&apos;;</span><br><span class="line">class MyComponent extends Component &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line">export default MyContainer(MyComponent);</span><br></pre></td></tr></table></figure></p><h2 id="七、组件性能优化"><a href="#七、组件性能优化" class="headerlink" title="七、组件性能优化"></a>七、组件性能优化</h2><p><a href="https://segmentfault.com/a/1190000006100489" target="_blank" rel="noopener">相关文章</a></p><ol><li>PureRender,immutable</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; is &#125; from &apos;immutable&apos;;</span><br><span class="line">class App extends Component &#123;</span><br><span class="line">    //shouldComponentUpdate-&gt;rener-&gt;diff dom</span><br><span class="line">    shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">        const thisProps = this.props || &#123;&#125;;</span><br><span class="line">        const thisState = this.state || &#123;&#125;;</span><br><span class="line">        if (Object.keys(thisProps).length !==                              Object.keys(nextProps).length ||</span><br><span class="line">            Object.keys(thisState).length !==                              Object.keys(nextState).length) &#123;</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        for (const key in nextProps) &#123;</span><br><span class="line">            if (nextProps.hasOwnProperty(key) &amp;&amp;</span><br><span class="line">                !is(thisProps[key], nextProps[key])) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    for (const key in nextState) &#123;</span><br><span class="line">        if (nextState.hasOwnProperty(key) &amp;&amp;</span><br><span class="line">            !is(thisState[key], nextState[key])) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>key(唯一值)</li></ol><h2 id="八、相关demo"><a href="#八、相关demo" class="headerlink" title="八、相关demo"></a>八、相关demo</h2><p><a href="https://github.com/xiaowangmm2/react-demo/tree/master/react-form-demo" target="_blank" rel="noopener">地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;react-study2&quot;&gt;&lt;a href=&quot;#react-study2&quot; class=&quot;headerlink&quot; title=&quot;react-study2&quot;&gt;&lt;/a&gt;react-study2&lt;/h1&gt;&lt;p&gt;标签（空格分隔）： react&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;一、-事件&quot;&gt;&lt;a href=&quot;#一、-事件&quot; class=&quot;headerlink&quot; title=&quot;一、 事件&quot;&gt;&lt;/a&gt;一、 事件&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;react事件写法与html事件写法区别&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;react： onClick={this.handleClick} 驼峰写法 值可以是任意类型&lt;/li&gt;
&lt;li&gt;html: onclick=”handleClick()” 小写  值只能是字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;react事件机制&lt;br&gt;在 React 底层，主要对合成事件做了两件事：事件委派和自动绑定。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;事件委派&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;react事件绑定并不会把事件处理函数直接绑定到真实的节点上，而是把所有事件绑定到&lt;strong&gt;结构的最外层&lt;/strong&gt;，使用一个统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象；当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率也有很大提升。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自动绑定&lt;/p&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1. bind方式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;button onClick=&amp;#123;this.handleClick.bind(this, &amp;apos;test&amp;apos;)&amp;#125;&amp;gt;Test&amp;lt;/button&amp;gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 双冒号语法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;button onClick=&amp;#123;::this.handleClick&amp;#125;&amp;gt;Test&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. 构造器内声明&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;constructor(props) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    super(props);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.handleClick = this.handleClick.bind(this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4. 箭头语法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const handleClick = (e) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;&lt;p&gt;react中使用原生事件&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import React, &amp;#123; Component &amp;#125; from &amp;apos;react&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class NativeEventDemo extends Component &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;componentDidMount() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.refs.button.addEventListener(&amp;apos;click&amp;apos;, e =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.handleClick(e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;handleClick(e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;componentWillUnmount() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//值得注意的是，在 React中使用DOM原生事件时，一定要在组件卸载时手动移除，否则很可能出现内存泄漏的问题。而使用合成事件系统时则不需要，因为 React 内部已经帮你妥善地处理了。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.refs.button.removeEventListener(&amp;apos;click&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;render() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return &amp;lt;button ref=&amp;quot;button&amp;quot;&amp;gt;Test&amp;lt;/button&amp;gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;react事件与原生事件的对比&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;事件机制&lt;br&gt;原生事件： 可以分为3个阶段：事件捕获阶段、目标对象本身的事件处理程序调用以及事件冒泡。&lt;br&gt;react事件： 并没有实现事件捕获，仅仅支持了事件冒泡机制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;事件类型&lt;br&gt;React 合成事件的事件类型是 JavaScript 原生事件类型的一个子集&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;事件绑定方式&lt;br&gt;原生：&lt;/p&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//dom上绑定&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;button onclick=&amp;quot;alert(1);&amp;quot;&amp;gt;Test&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//属性赋值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;el.onclick = e =&amp;gt; &amp;#123; console.log(e); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//事件监听函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;el.addEventListener(&amp;apos;click&amp;apos;, () =&amp;gt; &amp;#123;&amp;#125;, false);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;el.attachEvent(&amp;apos;onclick&amp;apos;, () =&amp;gt; &amp;#123;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;事件对象&lt;br&gt;原生： IE与现代浏览器有差异&lt;br&gt;react: 无差异&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="react" scheme="https://xiaowangmm2.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://xiaowangmm2.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react简介</title>
    <link href="https://xiaowangmm2.github.io/posts/de3ba3c/"/>
    <id>https://xiaowangmm2.github.io/posts/de3ba3c/</id>
    <published>2017-09-18T03:04:58.000Z</published>
    <updated>2018-06-12T06:13:41.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react-study1"><a href="#react-study1" class="headerlink" title="react-study1"></a>react-study1</h1><p>标签（空格分隔）： react</p><hr><h2 id="一、react简介"><a href="#一、react简介" class="headerlink" title="一、react简介"></a>一、react简介</h2><ul><li>专注视图层<br>  可以与其他框架搭配，构建大型应用.</li><li><p>虚拟dom，性能(dom操作性能消耗最大)。<br>  真实页面对应一个 DOM 树。</p><ul><li>传统：传统页面的开发模式中，每次需要更新页面时，都要手动操作 DOM 来进行更新</li><li><code>每次数据更新后</code>，重新计算 Virtual DOM，并和上一次生成的 Virtual DOM 做对比，对发生变化的部分做批量更新。React 也提供了直观的 shouldComponentUpdate 生命周期回调，来减少数<br>据变化后不必要的 Virtual DOM 对比过程，以保证性能</li></ul></li><li><p><a href="#fun">函数式编程(react的精髓)</a></p></li><li><a href="#jsx">jsx语法</a></li></ul><p><span id="fun"></span></p><h2 id="二、函数式编程"><a href="#二、函数式编程" class="headerlink" title="二、函数式编程"></a>二、函数式编程</h2><ul><li>对比<ul><li>命令式编程：命令式编程解决的是做什么的问题，执行命令,命令式编程关心解决问题的步骤</li><li>函数式编程：是一种”编程范式”（programming paradigm），主要思想是把运算过程尽量<code>写成一系列嵌套的函数调用</code>,函数式编程关心数据的映射</li></ul></li><li>特点<ul><li>函数是”第一等公民”，指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值</li><li>只用”表达式”，不用”语句”<br>“表达式”（expression）是一个单纯的运算过程，<code>总是有返回值</code>；”语句”（statement）是<code>执行某种操作，没有返回值</code>。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。</li><li>没有”副作用”<br>函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</li><li>不修改状态<br>函数式编程只是返回新的值，不修改系统变量。</li><li>引用透明<br>引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或”状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。</li></ul></li><li>意义<ul><li>代码简洁，开发快速<br>函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。</li><li>接近自然语言，易于理解（demo）</li><li>更方便的代码管理<br>函数式编程不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同。因此，每一个函数都可以被看做独立单元，很有利于进行单元测试（unit testing）和除错（debugging），以及模块化组合。</li><li>易于”并发编程”</li></ul></li></ul><p><span id="jsx"></span><br><a id="more"></a></p><h2 id="三、-jsx语法"><a href="#三、-jsx语法" class="headerlink" title="三、 jsx语法"></a>三、 jsx语法</h2><h3 id="1-jsx的由来"><a href="#1-jsx的由来" class="headerlink" title="1. jsx的由来"></a>1. jsx的由来</h3><ul><li>描述<br>虚拟元素可以理解为真实元素的对应，它的构建与更新都是在内存中完成的，并不会真正渲染到 DOM 中去。在 React中创建的虚拟元素可以分为两类，<strong>DOM 元素（DOM element）</strong><br>与<strong>组件元素（component element）</strong>，分别对应着原生 DOM 元素与自定义元素，而 JSX 与创建元素的过程有着莫大的关联</li><li>dom元素的，react的创建元素类似</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;button class=&quot;btn btn-blue&quot;&gt;</span><br><span class="line">  &lt;em&gt;Confirm&lt;/em&gt;</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> type: &apos;button&apos;,</span><br><span class="line"> props: &#123;</span><br><span class="line">   className: &apos;btn btn-blue&apos;,</span><br><span class="line">   children: [&#123;</span><br><span class="line">  type: &apos;em&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line"> children: &apos;Confirm&apos;</span><br><span class="line">  &#125;</span><br><span class="line">   &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ps: 在 React 中，到处都是可以复用的元素，这些元素并不是真实的实例，它只是让 React 告诉</span><br><span class="line">开发者想要在屏幕上显示什么。我们无法通过方法去调用这些元素，它们只是不可变的描述对象</span><br></pre></td></tr></table></figure><ul><li>组件元素，react的创建元素类似</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const Button = (&#123; color, text &#125;) =&gt; &#123;</span><br><span class="line"> return &#123;</span><br><span class="line"> type: &apos;button&apos;,</span><br><span class="line">   props: &#123;</span><br><span class="line">  className: `btn btn-$&#123;color&#125;`,</span><br><span class="line">  children: &#123;</span><br><span class="line"> type: &apos;em&apos;,</span><br><span class="line"> props: &#123;</span><br><span class="line">   children: text,</span><br><span class="line"> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">   &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">//创建组件元素的json格式</span><br><span class="line">&#123;</span><br><span class="line"> type: Button,</span><br><span class="line"> props: &#123;</span><br><span class="line">   color: &apos;blue&apos;,</span><br><span class="line">   children: &apos;Confirm&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-jsx的基本语法"><a href="#2-jsx的基本语法" class="headerlink" title="2. jsx的基本语法"></a>2. jsx的基本语法</h3><ul><li>基本语法<br>  定义标签时，只允许被一个标签包裹;<br>  标签一定要闭合</li><li>元素类型<br>  dom元素： 标签首字母为<code>小写字母</code><br>  组件元素：标签首字母对应<code>大写首字母</code></li><li><p>注释<br>  {/<em> 节点注释 </em>/}<br>  条件注释：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[if IE]&gt;</span><br><span class="line">&lt;p&gt;Work in IE browser&lt;/p&gt;</span><br><span class="line">&lt;![endif]--&gt;</span><br><span class="line">&#123;</span><br><span class="line">    (!!window.ActiveXObject || &apos;ActiveXObject&apos; in window) ?</span><br><span class="line">    &lt;p&gt;Work in IE browser&lt;/p&gt; : &apos;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>元素属性<br>  class 属性改为 className；<br>  for 属性改为 htmlFor；<br>  在写自定义属性的时候，都由标准写法改为小驼峰写法</p></li><li><p>Boolean 属性<br>  省略 Boolean 属性值会导致 JSX 认为 bool 值设为了 true。要传 false 时，必须使用属性表达式</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Checkbox checked=&#123;true&#125; /&gt;</span><br><span class="line">&lt;Checkbox checked /&gt;</span><br><span class="line">&lt;Checkbox checked=&#123;false&#125; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>展开属性<br>  可以使用 ES6 rest/spread 特性来提高效率</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    const data = &#123; name: &apos;foo&apos;, value: &apos;bar&apos; &#125;;</span><br><span class="line">    const component = &lt;Component name=&#123;data.name&#125; value=&#123;data.value&#125; /&gt;;</span><br><span class="line">可以写成：</span><br><span class="line">const data = &#123; name: &apos;foo&apos;, value: &apos;bar&apos; &#125;;</span><br><span class="line">const component = &lt;Component &#123;...data&#125; /&gt;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-JavaScript-属性表达式"><a href="#3-JavaScript-属性表达式" class="headerlink" title="3. JavaScript 属性表达式"></a>3. JavaScript 属性表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const person = &lt;Person name=&#123;window.isLoggedIn ? window.name : &apos;&apos;&#125; /&gt;;</span><br></pre></td></tr></table></figure><h3 id="4-html转义"><a href="#4-html转义" class="headerlink" title="4.html转义"></a>4.html转义</h3><p>React 会将所有要显示到 DOM 的字符串转义，防止 XSS。</p><ul><li>直接使用 UTF-8 字符</li><li>使用对应字符的 Unicode 编码查询编码；</li><li>使用数组组装 <div>{[‘cc ‘, <span>&copy;</span>, ‘ 2015’]}</div>；</li><li>直接插入原始的 HTML</li><li>React 提供了 dangerouslySetInnerHTML 属性。它的作用就是避免 React 转义字符，在确定必要的情况下可以使用它：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div dangerouslySetInnerHTML=&#123;&#123;__html: &apos;cc &amp;copy; 2015&apos;&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure><h2 id="四、React组件"><a href="#四、React组件" class="headerlink" title="四、React组件"></a>四、React组件</h2><h3 id="1-狭义上的组件，UI组件。"><a href="#1-狭义上的组件，UI组件。" class="headerlink" title="1. 狭义上的组件，UI组件。"></a>1. 狭义上的组件，UI组件。</h3><p><strong>说明</strong>：组件主要围绕在交互动作上的抽象，针对这些交互动作，利用 <code>JavaScript 操作 DOM 结构或 style 样式</code>来控制。一般会有 3 个部分组件：<code>结构、样式和交互行为</code></p><ul><li><a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">其他知识点Class</a></li><li><a href="https://github.com/xiaowangmm2/react-demo/tree/master/react-component-demo" target="_blank" rel="noopener">demo实例</a></li><li>规范标准组件的信息<ul><li><strong>基本的封装性</strong>。尽管说JavaScript没有真正面向对象的方法，但我们还是可以通过实例化的方法来制造对象。</li><li><strong>简单的生命周期呈现</strong>。最明显的两个方法 constructor 和 destroy，代表了组件的挂载和卸载过程。但除此之外，其他过程（如更新时的生命周期）并没有体现。</li><li><strong>明确的数据流动</strong>。这里的数据指的是调用组件的参数。一旦确定参数的值，就会解析传进来的参数，根据参数的不同作出不同的响应，从而得到渲染结果。</li></ul></li><li>mvc架构的演变，模板引擎的加入，可以解决view层</li><li>弊端：通过改变 class 控制 style 来显示或隐藏。这样的逻辑一旦复杂，就存在大量的 DOM 操作，<br>开发及维护成本相当高。</li></ul><h3 id="2-广义上的组件，带有业务含义和数据的-UI-组件组合"><a href="#2-广义上的组件，带有业务含义和数据的-UI-组件组合" class="headerlink" title="2. 广义上的组件，带有业务含义和数据的 UI 组件组合"></a>2. 广义上的组件，带有业务含义和数据的 UI 组件组合</h3><p>这类组件不仅有交互动作，更重要的是有<code>数据与界面之间的交互</code>。</p><ul><li>Web Components</li><li>react组件： React组件基本上由3个部分组成——属性（props）、状态（state）以及生命周期方法<br><strong>说明</strong>：React 组件可以接收参数，也可能有自身状态。一旦接收到的参数或自身状态有所改变，React组件就会执行相应的生命周期方法，最后渲染。整个过程完全符合传统组件所定义的组件职责。<br>  <img src="http://chuantu.biz/t6/46/1505202253x1944864576.png" alt="组件"></li><li>对比<ul><li>React 自定义元素是库自己构建的，与 Web Components 规范并不通用；</li><li>React 渲染过程包含了模板的概念，即 1.2 节所讲的 JSX；</li><li>React 组件的实现均在方法与类中，因此可以做到相互隔离，但不包括样式；</li><li>React 引用方式遵循 ES6 module 标准。</li></ul></li></ul><h3 id="3-react组件创建"><a href="#3-react组件创建" class="headerlink" title="3. react组件创建"></a>3. react组件创建</h3><ul><li><p>React.createClass</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const Button = React.createClass(&#123;</span><br><span class="line"> getDefaultProps() &#123;</span><br><span class="line">   return &#123;</span><br><span class="line">  color: &apos;blue&apos;,</span><br><span class="line">  text: &apos;Confirm&apos;,</span><br><span class="line">   &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"> render() &#123;</span><br><span class="line">   const &#123; color, text &#125; = this.props;</span><br><span class="line"></span><br><span class="line">   return (</span><br><span class="line">  &lt;button className=&#123;`btn btn-$&#123;color&#125;`&#125;&gt;</span><br><span class="line">    &lt;em&gt;&#123;text&#125;&lt;/em&gt;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">   );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>ES6 classes</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">class Button extends Component &#123;</span><br><span class="line"> constructor(props) &#123;</span><br><span class="line">   super(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> static defaultProps = &#123;</span><br><span class="line">   color: &apos;blue&apos;,</span><br><span class="line">  text: &apos;Confirm&apos;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> render() &#123;</span><br><span class="line">   const &#123; color, text &#125; = this.props;</span><br><span class="line"></span><br><span class="line">   return (</span><br><span class="line">  &lt;button className=&#123;`btn btn-$&#123;color&#125;`&#125;&gt;</span><br><span class="line">    &lt;em&gt;&#123;text&#125;&lt;/em&gt;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">   );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>无状态函数(无状态组件)<br>它不存在 state，也没有生命周期方法,无状态组件。不像上述两种方法在调用时会创建新实例，它<code>创建时始终保持了一个实例</code>，避免了不必要的检查和内存分配，做到了内部优化。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Button(&#123; color = &apos;blue&apos;, text = &apos;Confirm&apos; &#125;) &#123;</span><br><span class="line"> return (</span><br><span class="line">   &lt;button className=&#123;`btn btn-$&#123;color&#125;`&#125;&gt;</span><br><span class="line">  &lt;em&gt;&#123;text&#125;&lt;/em&gt;</span><br><span class="line">   &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>es6与es5差异<br><img src="http://chuantu.biz/t6/47/1505266423x2890149518.png" alt="差异"></li></ul><h2 id="五-react数据流"><a href="#五-react数据流" class="headerlink" title="五. react数据流"></a>五. react数据流</h2><ul><li>概念<blockquote><p>在 React 中，数据是自顶向下单向流动的，即从父组件到子组件。这条原则让组件之间的关系变得简单且可预测。</p></blockquote>state 与 props 是 React 组件中最重要的概念。如果顶层组件初始化 props，那么 React会向下遍历整棵组件树，重新尝试渲染所有相关的子组件。而 state只关心每个组件自己内部的状态，这些状态只能在组件内改变。把组件看成一个函数，那么它接受了props作为参数，内部由 state 作为函数的内部参数，返回一个 Virtual DOM 的实现。</li><li>state</li><li>props</li></ul><h2 id="六-react生命周期"><a href="#六-react生命周期" class="headerlink" title="六. react生命周期"></a>六. react生命周期</h2><ul><li><a href="#render">当组件在挂载或卸载时</a></li><li><a href="#update">当组件接收新的数据时，即组件更新时</a></li></ul><p><img src="http://chuantu.biz/t6/47/1505265743x2890174297.png" alt="生命周期"></p><p><span id="render"></span></p><h3 id="组件挂载、卸载"><a href="#组件挂载、卸载" class="headerlink" title="组件挂载、卸载"></a>组件挂载、卸载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line"> static propTypes = &#123;</span><br><span class="line">  // 挂载过程 执行一次</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> static defaultProps = &#123;</span><br><span class="line">  // 挂载过程 执行一次</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> constructor(props) &#123;</span><br><span class="line"> // 挂载过程 执行一次</span><br><span class="line">   super(props);</span><br><span class="line"></span><br><span class="line">   this.state = &#123;</span><br><span class="line">  // ...</span><br><span class="line">   &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> componentWillMount() &#123;</span><br><span class="line"> // if setState 挂载过程 render一次</span><br><span class="line">  &#125;</span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line"> // if setState 挂载过程 render两次</span><br><span class="line">  &#125;</span><br><span class="line"> componentWillUnmount() &#123;</span><br><span class="line">  // 卸载过程执行</span><br><span class="line">  // 我们常常会执行一些清理方法，如事件回收或是清除定时器。</span><br><span class="line">  &#125;</span><br><span class="line"> render() &#123;</span><br><span class="line">   return &lt;div&gt;This is a demo.&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="update"></span></p><h3 id="数据更新过程"><a href="#数据更新过程" class="headerlink" title="数据更新过程"></a>数据更新过程</h3><p>说明：更新过程指的是父组件向下传递 props或组件自身执行setState 方法时发生的一系列更新动作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line"> componentWillReceiveProps(nextProps) &#123;</span><br><span class="line"> // this.setState(&#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line"> // return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> componentWillUpdate(nextProps, nextState) &#123;</span><br><span class="line"> // 不能执行 setState</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line"> // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> render() &#123;</span><br><span class="line">   return &lt;div&gt;This is a demo.&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>state更新</li></ol><p>如果组件自身的 state更新了，那么会依次执行shouldComponentUpdate、componentWillUpdate 、render 和 componentDidUpdate。</p><ol start="2"><li>shouldComponentUpdate<br>shouldComponentUpdate 是一个特别的方法，它接收需要更新的 props 和 state，让开发者增加必要的条件判断，让其在需要时更新，不需要时不更新。因此，当方法返回false的时候，组件不再向下执行生命周期方法。</li></ol><h2 id="七-React-与-DOM"><a href="#七-React-与-DOM" class="headerlink" title="七. React 与 DOM"></a>七. React 与 DOM</h2><h3 id="ReactDOM"><a href="#ReactDOM" class="headerlink" title="ReactDOM"></a>ReactDOM</h3><ol><li>findDOMNode获取dom</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate</span><br><span class="line">componentDidMount() &#123;</span><br><span class="line"> // this 为当前组件的实例</span><br><span class="line"> const dom = ReactDOM.findDOMNode(this);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>refs,组件被调用时会新建一个该组件的实例，而refs就会指向这个实例。如果是无状态组件，render会返回null。无状态组件挂载时只是方法调用，没有新建实例.<br>refs 同样支持字符串。对于 DOM 操作，不仅可以使用 findDOMNode 获得该组件 DOM，还可以使用 refs 获得组件内部的 DOM。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">// myComp 是 Comp 的一个实例，因此需要用 findDOMNode 转换为相应的 DOM</span><br><span class="line"> const myComp = this.refs.myComp;</span><br><span class="line"> const dom = findDOMNode(myComp);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="八、相关demo"><a href="#八、相关demo" class="headerlink" title="八、相关demo"></a>八、相关demo</h2><p><a href="https://github.com/xiaowangmm2/react-demo/tree/master/react-component-demo" target="_blank" rel="noopener">地址</a></p><h2 id="相关链接："><a href="#相关链接：" class="headerlink" title="相关链接："></a>相关链接：</h2><ul><li><a href="https://facebook.github.io/react/" target="_blank" rel="noopener">react官网</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html" target="_blank" rel="noopener">阮一峰函数式编程</a></li><li><a href="http://taobaofed.org/blog/2017/03/16/javascript-functional-programing/" target="_blank" rel="noopener">fed函数式编程</a></li><li><a href="https://gist.github.com/jcouyang/b56a830cd55bd230049f" target="_blank" rel="noopener">柯里化</a></li><li><a href="http://javascript.ruanyifeng.com/htmlapi/webcomponents.html" target="_blank" rel="noopener">webcomponents阮一峰</a></li><li><a href="http://sentsin.com/web/1089.html" target="_blank" rel="noopener">webcomponents</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;react-study1&quot;&gt;&lt;a href=&quot;#react-study1&quot; class=&quot;headerlink&quot; title=&quot;react-study1&quot;&gt;&lt;/a&gt;react-study1&lt;/h1&gt;&lt;p&gt;标签（空格分隔）： react&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;一、react简介&quot;&gt;&lt;a href=&quot;#一、react简介&quot; class=&quot;headerlink&quot; title=&quot;一、react简介&quot;&gt;&lt;/a&gt;一、react简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;专注视图层&lt;br&gt;  可以与其他框架搭配，构建大型应用.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;虚拟dom，性能(dom操作性能消耗最大)。&lt;br&gt;  真实页面对应一个 DOM 树。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传统：传统页面的开发模式中，每次需要更新页面时，都要手动操作 DOM 来进行更新&lt;/li&gt;
&lt;li&gt;&lt;code&gt;每次数据更新后&lt;/code&gt;，重新计算 Virtual DOM，并和上一次生成的 Virtual DOM 做对比，对发生变化的部分做批量更新。React 也提供了直观的 shouldComponentUpdate 生命周期回调，来减少数&lt;br&gt;据变化后不必要的 Virtual DOM 对比过程，以保证性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#fun&quot;&gt;函数式编程(react的精髓)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#jsx&quot;&gt;jsx语法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span id=&quot;fun&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、函数式编程&quot;&gt;&lt;a href=&quot;#二、函数式编程&quot; class=&quot;headerlink&quot; title=&quot;二、函数式编程&quot;&gt;&lt;/a&gt;二、函数式编程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;对比&lt;ul&gt;
&lt;li&gt;命令式编程：命令式编程解决的是做什么的问题，执行命令,命令式编程关心解决问题的步骤&lt;/li&gt;
&lt;li&gt;函数式编程：是一种”编程范式”（programming paradigm），主要思想是把运算过程尽量&lt;code&gt;写成一系列嵌套的函数调用&lt;/code&gt;,函数式编程关心数据的映射&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;特点&lt;ul&gt;
&lt;li&gt;函数是”第一等公民”，指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值&lt;/li&gt;
&lt;li&gt;只用”表达式”，不用”语句”&lt;br&gt;“表达式”（expression）是一个单纯的运算过程，&lt;code&gt;总是有返回值&lt;/code&gt;；”语句”（statement）是&lt;code&gt;执行某种操作，没有返回值&lt;/code&gt;。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。&lt;/li&gt;
&lt;li&gt;没有”副作用”&lt;br&gt;函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。&lt;/li&gt;
&lt;li&gt;不修改状态&lt;br&gt;函数式编程只是返回新的值，不修改系统变量。&lt;/li&gt;
&lt;li&gt;引用透明&lt;br&gt;引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或”状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;意义&lt;ul&gt;
&lt;li&gt;代码简洁，开发快速&lt;br&gt;函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。&lt;/li&gt;
&lt;li&gt;接近自然语言，易于理解（demo）&lt;/li&gt;
&lt;li&gt;更方便的代码管理&lt;br&gt;函数式编程不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同。因此，每一个函数都可以被看做独立单元，很有利于进行单元测试（unit testing）和除错（debugging），以及模块化组合。&lt;/li&gt;
&lt;li&gt;易于”并发编程”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span id=&quot;jsx&quot;&gt;&lt;/span&gt;&lt;br&gt;
    
    </summary>
    
      <category term="react" scheme="https://xiaowangmm2.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://xiaowangmm2.github.io/tags/react/"/>
    
  </entry>
  
</feed>
